#Android关于OOM的解决方案
##OOM
* 内存溢出（Out Of Memory）
* 也就是说内存占有量超过了VM所分配的最大(Dalvik Heap size)可以通过adb shell getprop | grep dalvik.vm.heapgrowthlimit查看限制大小



##出现OOM的原因
1. 加载对象过大
2. 相应资源过多，来不及释放*
3. 过多的内存泄露

##如何解决
1. 在内存引用上做些处理，常用的有软引用、强化引用、弱引用
2. 在内存中加载图片时直接在内存中作处理，如图片边界压缩
3. 动态回收内存*
4. 优化Dalvik虚拟机的堆内存分配(调整最大最小空闲内存以及堆利用率) 通过android:largeHeap = true使用dalvik.vm.heapsize
5. 自定义堆内存大小*

强引用（StrongReference）：如果一个对象具有强引用，那垃圾回收器绝不会回收它。
当内存空间不足时，java虚拟机宁愿抛出OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
		生存时间:JVM 停止运行时终止

软引用（softReference）：用来描述一些还有用但并非必须的对象。如果一个对象只具有软引用，则内存空间充足时，垃圾回收器不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。
             软引用可以用来实现内存敏感的高速缓存。
             生存时间:内存不足时终止

弱引用（WeakReference）：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
	jvm 首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收；
	如果一个对象是偶尔的使用，并且希望在使用时随时就能获取到，但是又不想影响对象的垃圾收集，那么就可以用Weak Reference 来记住此对象。
	 生存时间:垃圾回收后终止

虚引用（PhanttomReference）:虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
	生存时间:垃圾回收后终止


垃圾回收器	
在android 采用的是标志并删除和拷贝GC 算法。
标记回收算法：
从GC ROOT 进行遍历，把可达对象都标记，剩下那些不可达的进行回收，这种方式需要中断其他线程，并且可能产生内存碎片。
GC ROOT 有几种：
1、Class-- 由系统类加载器加载的对象，这些类不可以被回收，他们可以以静态字段的方式持有其他对象。
2、Thread ：活着的线程
3、Stack Local： java 方法的local 变量 或参数（存在于所有java线程当前活跃的栈帧里，它们会指向堆里的对象）
4、JNI Local：jni 方法的local 变量或参数
5、JNI Global 全局JNI 引用

GC 收集那些不是GC ROOTS 且没有被GC Roots 引用的对象






